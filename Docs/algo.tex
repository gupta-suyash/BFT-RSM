\section{\Shadow{} Protocol}
\label{s:algo}
We now describe our \Scrooge{} protocol that aims to efficiently implement the \CCC{} primitive.
Prior works attempt to implement the \CCC{} primitive in following ways:
(1) deploying trusted hardware and infrastructure,
(2) employing zero knowledge proofs, and
(3) concurrently sending multiple copies of each message.
The key challenge with the use of trusted hardware is that they 
are expected to remain honest, which makes them a sink for all attacks.
Solutions based on zero knowledge proofs 
are not only computationally expensive to generate, but also  and have high latencies.

Alternatively, each \RSM{} can create and send multiple copies of each message, 
but this design requires deciding which replica(s) in the \RSM{} will send the message to 
which replica(s) in the receiver \RSM{}.
Some \RSM{}-to-\RSM{} communication protocols opt for the hands-off {\em all-to-all} communication 
where every replica in the sending \RSM{} sends a copy of the message to every replica in the receiving \RSM{}.
Other protocols attempt to communicate only linear number of messages, but they 
fall back to the all-to-all communication for recovery from Byzantine attacks.
Moreover, these solutions expect a synchronous network.

\Scrooge{} does not face any of these challenges as it guarantees reliable delivery of the message 
with a constant number of copies and no trusted hardware.
To do so, \Scrooge{} supports both {\em unidirectional} and {\em bidirectional} communication.
Bidirectional communication helps to conserve bandwidth by piggybacking acknowledgments along with the messages; 
both the \RSM{s} can send/receive messages at the same time.

%Specifically, \Scrooge{} provides the following \RSM{}-to-\RSM{} communication properties.
%\begin{enumerate}[wide]
%	\item \textbf{Basic Data Transfer:} \Scrooge{} provides a ``push'' functionality, which guarantees that any message, which a replica of the 
%sending \RSM{} wants to send will be eventually sent to a receiver.
%	\item \textbf{Message Reliability:} Any message dropped or delayed by Byzantine replicas is eventually received by honest replicas.
%To achieve this property, we acknowledge receipt of each message.
%	\item {\bf Flow Control:} \Scrooge{} ensures that a message is only re-send if and only if a sufficient number of honest replicas 
%have implicitly acknowledged its non-receipt.
%\end{enumerate}

{\bf Message Format.}
\Scrooge{} expects each honest replica to send only transactions (or blocks of transactions) 
committed at its \RSM{}. 
Each such committed block of transactions (say $m$) is assigned a unique sequence number (say $\Seqn$), and 
a {\em quorum} of \RSM{} replicas agree to order $m$ at $\Seqn$.
In the case of \BFT{} and \PoS{} systems, the agreement by a quorum of replicas is represented through 
the digital signatures of each replica in the quorum. 
We use the notation $\SignMessage{m, \Seqn}{\Qusign{i}}$ to represent a committed block of transactions where
$\Qusign{i}$ is a set of digital signatures (\DS{}) on $\langle m, \Seqn \rangle$ by a quorum of replicas 
of the $i$-th \RSM{}.
For \BFT{} and \PoS{} systems, we assume the quorum size, $\abs{\Qusign{i}}$ to be at least $2\f{i}+1$ 
while $\abs{\Qusign{i}} = \f{i} + 1$ for \CFT{} systems.
%Finally, we do not make any assumption on the content of $m$; 
%\Scrooge{} does not verify the state change on executing $m$ at the receiver \RSM{}.
%We assume that the Byzantine replicas can neither impersonate honest replicas, nor subvert cryptographic constructs.



{\bf Data Structures.} 
To lay down \Scrooge{} protocol, in the remaining section, we assume that \RSM{s} $\SMR{i}$ and $\SMR{j}$ have access to a 
steady stream of committed messages that they want to communicate.
%Each message communicated using \Scrooge{} has two parts: 
%(1) {\em data}, which represents client data, transaction or contract, and 
%(2) {\em sequence number}, which represents the order at which data was committed.
Let $\SSet{i}$ be the set of all messages to be sent by $i$-th \RSM{} $\SMR{i}$, such that:
\begin{equation*}
\SSet{i} = \{\SignMessage{m, 1}{\Qusign{i}},  \SignMessage{m, 2}{\Qusign{i}}, ... , \SignMessage{m, \Seqn}{\Qusign{i}}, ... \} 
\end{equation*}
%Here, $\SignMessage{m, \Seqn}{\Qusign{i}}$ represents data $m$ committed at sequence number $\Seqn$ by a quorum of replicas in \RSM{} $\SMR{i}$.
For the sake of explanation, we assume that all the sequence numbers are monotonically increasing and 
there is no gap in the ordered list of sequence numbers.

In Section~\ref{s:prelim}, we stated that each replica in \RSM{} $\SMR{i}$ is assigned two identifiers:
\RSM{} identifier and share identifier.
If all the replicas have equal share, then $\n{i} = \ts{i}$ and both the identifiers are same.
We use these identifiers to determine which replica should send which message.
To do so, we require each replica to maintain several data-structures, which we define next.
Assume, $l$-th replica $\Replica{i}{l}$ of \RSM{} $\SMR{i}$ has share $\share{l}$ and 
$\SID{l}$ and $\SID{l-1}$ be the share identifiers of replicas $\Replica{i}{l}$ and $\Replica{i}{(l-1)}$.

\begin{itemize}[wide]
\item $\Sbuf{l} = \{\SignMessage{m, k}{\Qusign{i}} ~|~ k ~\equiv q \pmod{t_i} ~\wedge ~q \in (\SID{l-1}, \SID{l}] ~\wedge  ~\SignMessage{m, k}{\Qusign{i}} \in \SSet{i} \}$, the set of messages to be sent by $\Replica{i}{l}$, maintained as a queue.

\item $\Hbuf{l} = \SSet{i} - \Sbuf{l}$, the remaining set of messages.

\item $\Rbuf{l} = \{\SignMessage{m, k}{\Qusign{j}} ~|~ j \neq i ~\wedge ~\SignMessage{m, k}{\Qusign{j}} \in \SSet{j} \}$, the messages received from \RSM{} $\SMR{j}$.

\item $\SAck{l} = \{\Ack{k} ~|~ \SignMessage{m, k}{\Qusign{j}} \in \Rbuf{l} \}$, the acknowledgments for messages received from \RSM{} $\SMR{j}$.

\end{itemize}
%
We also require each replica in \RSM{} $\SMR{i}$ to count the number of acknowledgments it has received for 
each message in the set $\SSet{i}$ from the replicas in \RSM{} $\SMR{j}$. 
It maintains a map $\RAck{l}{}$ for this purpose. 
The following example illustrates the use of data-structures $\Sbuf{}$ and $\Hbuf{}$ in practice.


\begin{example}\label{ex:rep-send}
Assume two \RSM{s} $\SMR{i}$ and $\SMR{j}$ have $4$ replicas each: 
$\Replica{i}{1}$, $\Replica{i}{2}$, $\Replica{i}{3}$, and $\Replica{i}{4}$ at $\SMR{i}$, and 
$\Replica{j}{1}$, $\Replica{j}{2}$, $\Replica{j}{3}$, and $\Replica{j}{4}$ at $\SMR{j}$.
Say the replicas of \RSM{} $\SMR{i}$ plan to send a series of ordered messages, starting with sequence number $1$. 
So, the data-structures $\Sbuf{}$ and $\Hbuf{}$ for each replica in $\SMR{i}$ looks as follows:
$\Sbuf{1} = \{1,5,9,...\}$ and $\Hbuf{1} = \{2,3,4,6,7,8,...\}$, 
$\Sbuf{2} = \{2,6,10,...\}$ and $\Hbuf{2} = \{1,3,4,5,7,8,...\}$, 
$\Sbuf{3} = \{3,7,11,...\}$ and $\Hbuf{3} = \{1,2,4,5,6,8,...\}$, and
$\Sbuf{4} = \{4,8,12,...\}$ and $\Hbuf{4} = \{1,2,3,5,6,7,...\}$.
\end{example}



\subsection{Civil Case Protocol}
Next, we present the \Scrooge{} protocol in the good case (when there are no failures).


\begin{itemize}[wide]
\item {\bf Sharewise Scheduler.}
Our \Scrooge{} protocol ensures that the $l$-th replica $\Replica{i}{l}$ of the $i$-th \RSM{} $\SMR{i}$ sends 
each message in its $\Sbuf{l}$ to exactly one replica of the \RSM{} $\SMR{j}$.
To identify the correct receiver, we design a novel protocol, Sharewise Scheduler (\SWS{}), which 
is built on top of the Completely Fair Scheduler (\CFS{})~\cite{cfs} algorithm.
\CFS{} inserts various tasks, on the basis of their execution time, into a Red-Black Tree (\RBT) and 
schedules the task with the least execution time for processing.

Rather than using an \RBT{}, our \SWS{} protocol requires each replica of the sending \RSM{} to 
maintain a sorted list ($\SList$) of replicas of the receiving \RSM{}.
Specifically, each replica $\Replica{i}{l}$ of the sending \RSM{} $\SMR{i}$ 
calls the function {\bf sws} (in Figure~\ref{func:sws}) to determine its 
list of receivers ($\DList$) in \RSM{} $\SMR{j}$.
Depending on the shares of senders and receivers, 
a sender may be responsible for communication with multiple receivers and vice versa.
Notice that each sender replica $\Replica{i}{l}$ needs to call the function {\bf sws} only once per epoch. 


%The replicas are sorted on the value of their shares; 
%if two replicas have equal shares, then order the replicas on basis of their identifiers.
%Each replica $\Replica{i}{l}$ of the sending \RSM{} $\SMR{i}$ scans the list $\SList$
%and independently identifies the correct receiver for every replica in $\SMR{i}$.
%The first replica $\Replica{i}{l}$ ($l=0$) of $\SMR{i}$ selects from $\SList$ the replica with the smallest share. 
%Let $\Replica{j}{r}$ be the selected replica and $\share{l}$ and $\share{r}$ be the shares of $\Replica{i}{l}$ and $\Replica{j}{r}$, respectively. 
%If $\share{l} \ge \share{r}$, replica $\Replica{i}{l}$ dequeues $\share{r}$ messages from its $\Sbuf{l}$,
%sends these messages to $\Replica{j}{r}$, 
%removes $\Replica{j}{r}$ from $\SList{}$,
%temporarily reduces $\share{l}$ by $\share{r}$, and appends $\Replica{j}{r}$ to $\SList{}$ with the 
%updated share of $\Replica{j}{r}$ being the sum of total share $\ts{i}$ and $\share{r}$.
%Next, replica $\Replica{i}{l}$ selects the next replica in the sorted list and continues this process until 
%$\share{l}$ is equal to zero.
%If $\share{l} < \share{r}$, replica $\Replica{i}{l}$ dequeues $\share{l}$ messages from its $\Sbuf{l}$, 
%sends these messages to $\Replica{j}{r}$, and temporarily reduces the share $\share{r}$ by $\share{l}$ and sets $\share{l} = 0$.
%Once the share of replica $l=0$ is zero, we continue this process for the replica $l=1$ on the updated list. 

%To identify the correct destination, we design a pairwise round-robin algorithm; 
%$\Replica{i}{l}$ sends the message to replica $\Replica{j}{r}$ of \RSM{} $\SMR{j}$, 
%where $r$ represents the communication round and $r = (l+r) \bmod \n{j} ~\wedge ~r \in [1,\n{j}]$.
%Specifically, in each communication round, each replica $\Replica{i}{l}$ 
%sends a message to a replica of the other \RSM{}; the destination replica varies per round.
%A key advantage of switching destination is to prevent honest replicas to be stuck with byzantine replicas.


\begin{figure}[t]
    \begin{myprotocol}
	\INITIAL{Initialization:}{\newline
	{%\color{orange}
	// $\SMR{i} :=$ \RSM{} of the replica calling this function.\newline
	// $\SMR{j} :=$ Receiver \RSM{}.
	}}
	\vspace{1mm}

	\FUNC{sws}{caller's identifier: $a$}
		\STATE $\SList :=$ Sorted list of replicas of $\SMR{j}$ on the basis of shares.
		\FOR{$l$ : $1$ to $\n{i}$}
			\STATE $\share{l} :=$ share of replica $\Replica{i}{l}$.
			\WHILE{$\share{l} \ne 0$} 
				\STATE $\Replica{j}{r} :=$ replica with the smallest share in $\SList$.
				\STATE $\share{r} :=$ share of replica $\Replica{j}{r}$.
				\IF{$\share{l} > \share{r}$}
					\STATE $\share{l} := \share{l} - \share{r}$.
					\STATE Remove $\Replica{j}{r}$ from $\SList$.
				\ELSE
					\STATE $\share{r} := \share{r} - \share{l}$.
					\STATE Update $\share{r}$ of $\Replica{j}{r}$ in $\SList$.
				\ENDIF

				\IF{$a = l$}
					\STATE Append $\Replica{j}{r}$ to list $\DList$.
				\ENDIF
			\ENDWHILE
		\ENDFOR
		\STATE {\bf return} $\DList$.
	\ENDFUNC
	\SPACE

	\FUNC{transmit}{caller's identifier: $l$, list: $\DList$}
		\FOR{$r$ : replicas in $\DList$}
			\STATE $\Replica{j}{r} :=$ receiver replica with share $\share{r}$.
			\IF{$\share{r} > \share{l}$}
				\STATE Extract $\share{l}$ messages from $\Sbuf{l}$.
			\ELSE
				\STATE Extract $\share{r}$ messages from $\Sbuf{l}$.
			\ENDIF
			\STATE Send extracted messages to $\Replica{j}{r}$.
		\ENDFOR
	\ENDFUNC
    \end{myprotocol}
    \caption{Sharewise Scheduler protocol to identify the message receivers for each caller.}
    \label{func:sws}
\end{figure}


 

\item {\bf Transmit.}
On calling the function \SWS{}, each replica $\Replica{i}{l}$ receives a list of replicas ($\DList$) it needs 
to send messages.
\Scrooge{} requires $\Replica{i}{l}$ to send each replica in $\DList$ a unique message from its $\Sbuf{l}$.
To determine which messages from $\Replica{i}{l} $ each replica in $\DList$ receives, $\Replica{i}{l}$ calls the function 
{\bf transmit} in Figure~\ref{func:sws}.
In this function, we use the extracted messages to refer to messages with the least sequence number.

\begin{example}
Say the call to function $\SWS{}$ by replica $\Replica{i}{l}$ with share $\share{l} = 3$ returned 
$\DList{} = \{\Replica{j}{r}, \Replica{j}{s} \}$, such that $\share{r} = 2$ and $\share{s} = 3$.
Assume $\Sbuf{l} = \{ \SignMessage{m,k}{\Qusign{i}}, \SignMessage{m',k'}{\Qusign{i}}, \SignMessage{m^\circ,k^\circ}{\Qusign{i}}, \SignMessage{m^{\star},k^{\star}}{\Qusign{i}},... \}$, 
such that $k < k' < k^\circ < k^\star$.
After sending every three messages from $\Sbuf{l}$, $\Replica{i}{l}$ loops back to $\DList$.
Specifically, $\Replica{i}{l}$ extracts $\SignMessage{m,k}{\Qusign{i}}$ and $\SignMessage{m',k'}{\Qusign{i}}$ and sends to $\Replica{j}{r}$, 
extracts $\SignMessage{m^\circ,k^\circ}{\Qusign{i}}$ and sends to $\Replica{j}{s}$, and cycles back to $\Replica{j}{r}$
and sends it $\SignMessage{m^{\star},k^{\star}}{\Qusign{i}}$.
As a result, in each cycle $\Replica{i}{l}$ sends $\Replica{j}{s}$ only one message even though $\share{s} = 3$.

\end{example}





\item {\bf Cumulative Acknowledgments.}
If the two \RSM{s} are participating in bidirectional communication streams,  
it is possible that $\Replica{i}{l}$ may have received messages from some replicas in \RSM{} $\SMR{j}$.
We require $\Replica{i}{l}$ to acknowledge each message it received from \RSM{} $\SMR{j}$. 
To conserve bandwidth, instead of sending an acknowledgment for each received message, 
\Scrooge{} requires $\Replica{i}{l}$ to create cumulative acknowledgments and {\em piggyback} them with 
the outgoing messages.

Prior to sending a message,
each replica searches its list $\SAck{l}$ for the longest contiguous set of acknowledgments.
The last acknowledgment of this contiguous list is considered as the cumulative acknowledgment for all the 
messages in this list. 
Assume $\Ack{1}, \Ack{2}, ... , \Ack{k'}$ is one such longest contiguous set of acknowledgments.
If this is the case, then $\Replica{i}{l}$ appends acknowledgment $\Ack{k'}$ to the outgoing message.


 


\item {\bf \em Receipt.}
When the $r$-th replica $\Replica{j}{r}$ of the $j$-th \RSM{} receives the 
message $\SignMessage{m, k}{\Qusign{i}}$ and acknowledgment $\Ack{k'}$ from replica $\Replica{i}{l}$ of \RSM{} $\SMR{i}$,
it broadcasts the message and acknowledgment to all the replicas in its \RSM{}.
Replica $\Replica{j}{r}$ also uses the piggybacked cumulative acknowledgment $\Ack{k'}$ to determine the fate of the 
messages sent by its \RSM{} $\SMR{j}$ to replicas of \RSM{} $\SMR{i}$.
Specifically, replica $\Replica{j}{r}$ updates the data-structure $\RAck{r}{}$ as follows:
for all the values $u \in [1,k']$, increment $\RAck{r}{u}$ by one.
If any $\RAck{r}{u}$ reaches the count $\f{j}+1$, it marks the message $\SignMessage{m, u}{\Qusign{j}}$ 
as {\em delivered}.
We require replica $\Replica{j}{r}$ to keep track of the last delivered message  (one with highest sequence number till now)
in a variable $\highest{}$.

%Say the sequence number for $m$ be $l$.
%If $\Replica{\Cluster{X}}{i}$ has received all the messages with sequence number less than $l$ from cluster $\Cluster{Y}$, 
%it goes ahead and processes $m$. 
%If this is not the case, then $\Replica{\Cluster{X}}{i}$ stores $m$ at the index $l$ in $\Rbuf{}$.
%This $\Rbuf{}$ helps $\Replica{\Cluster{X}}{i}$ to determine the contiguous sequence of messages it has received to send a cumulative 
%acknowledgment in future.
%
%Each message $m'$ received by $\Replica{\Cluster{X}}{i}$ also includes a cumulative acknowledgment ($\Ack{k}$). 
%This is the acknowledgment from the replica $\Replica{\Cluster{Y}}{j}$ (sender of $m'$).
%Through this $\Ack{k}$, $\Replica{\Cluster{Y}}{j}$ wants to inform that it has received all the messages till sequence number $k$ 
%from cluster $\Cluster{X}$.
%This allows $\Replica{\Cluster{X}}{i}$ to increment the {\em counter} for each message with sequence number $\le k$ 
%in its $\Sbuf{}$ and $\Hbuf{}$.
%When the counter for any message reaches $\f{\Replicas{}}+1$, the corresponding message is removed from $\Sbuf{}$ or $\Hbuf{}$.
%We call this message to be {\em majority acknowledged}.


\end{itemize}


%\Scrooge{} requires each honest replica to acknowledge the receipt of a valid message. 
%When a replica $\Replica{i}{l}$ in \RSM{} $\SMR{i}$ receives a message with sequence number $\Seqn$ 
%from the \RSM{} $\SMR{j}$, 
%it creates an acknowledgment $\Ack{k}$ in set $\SAck{l}$.
%
%
%We visualize $\Rbuf{}$ as an array, which stores a copy of received message from the other cluster, 
%indexed by the sequence number.
%We also require replicas to acknowledge (\Name{Ack}) messages they have received from the other cluster. 
%But, sending $\n{}$ \Name{Ack} messages for each received messaged is expensive, so we make replicas send 
%cumulative acknowledgment messages, which help to acknowledge receipt of multiple messages in a shot. 
%In this draft, when a replica sends $\Ack{k}$, it implies that this replica has received all the messages 
%with sequence number less than or equal to $k$.
%Next, we discuss the protocol steps.



{\bf Complexity.}
In the normal-case, when there are no failures, every replica in either \RSM{} will send and receive each message.
Each receiver will get a message either from a replica in the other \RSM{} or through broadcast from a replica in its \RSM{}. 
So, {\em one} message delay to send a message across \RSM{}, and {\em two} message delays to send a message to all the replicas in a \RSM{}.
However, the sender cannot remove a message from its $\Sbuf{}$ or $\Hbuf{}$ unless it receives $\f{}+1$ cumulative $\Ack{}$ messages (majority acknowledged) 
from distinct replicas.
As cumulative acknowledgments imply  receipt of a sequence of messages, so at steady state {\em two} communications across \RSM{} 
per message.






