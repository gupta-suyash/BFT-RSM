\section{Formalising the \CCC{} primitive }
\label{s:prelim}
The \CCC{} primitive should be sufficiently general to support different communication and failure models. 

\subsection{System Model}

Prior to formally defining our new \CCC{} primitive, we briefly summarize the system model.
Consider a pair of communicating RSMS. For the sake of exposition,  we denote the sending \RSM{} $\SMR{s}$ as the {\bf sender} and the other \RSM{} $\SMR{r}$ as a {\bf receiver}. In practice, the communication between these \RSM{}s is full-duplex: both RSMs can send and receive messages.

Most modern \RSM{s} are either \textit{crash-fault-tolerant} (they guarantee consensus when up to $\f{}$ nodes crash) or \textit{byzantine-fault-tolerant} (they guarantee consensus when up to $\f{}$ nodes behave arbitrarily). In line with Scrooge's stated generality and efficiency goals, we adopt the \textit{UpRight} failure model~\cite{upright}, as it allows us to consider Byzantine nodes and crashed nodes in a unified model, allowing us to design a system that optimizes for each type of failure. In the UpRight failure model, Byzantine nodes may exhibit {\em commission failures}; they may deviate from the protocol. All other faulty nodes suffer from \textit{omission failures} only: they follow the protocol but may fail to send/receive messages. Crashed nodes, for instance, suffer from permanent omission failures once crashed.
In this setup, each \RSM{} consists of $\n{}$ replicas.  We denote the $j$-th replica at 
the $i$-th \RSM{} as $\Replica{i}{j}$ (where $i$ is either the \textbf{s}ender or the \textbf{r}eceiver RSM). Each \RSM{} interacts with a set of clients, of which arbitrarily many can be faulty.

We say that an \RSM{} is safe despite up to $\rf{}$ commission failures and live despite up to $\uf{}$ failures of any kind.
For example, using UpRight model, we can describe traditional \BFT{} and \CFT{} \RSM{s} using just one equation: $2\uf{}+\rf{}+1$; 
$\uf{}=\rf{}=\f{}$ is a $3\f{}+1$ \BFT{} and $\rf{}=0$ is a $2\f{}+1$ \CFT{} \RSM{}.
%
Safety and liveness of any \RSM{} is defined as follows:
\begin{description}
\item[\bf Safety.]
If two honest replicas $\Replica{i}{1}$ and $\Replica{i}{2}$ commit transactions $\Transaction{}$ and $\Transaction{'}$
at sequence number $k$, then $\Transaction{} = \Transaction{'}$.

\item[\bf Liveness.]
If a client sends a transaction $\Transaction{}$, then it will eventually receive a response for $\Transaction{}$.
\end{description}

Note that we make no assumptions about the communication model of the underlying \RSM{}. 
We only assume messages are eventually delivered and that the receiver \RSM{} $\SMR{r}$ can verify whether a transaction was in fact 
committed by the sender \RSM{} $\SMR{s}$. 
We denote a committed transaction as $\SignMessage{\Transaction}{Q}$.

We generalize our system model to support \textit{shares}. The notion of share is used in stake-based \BFT{} consensus protocols where the value of a share determines the \textit{decision making power of a replica}~\cite{blockchain-book}. We write
$\share{ij}$ for the share of $\Replica{i}{j}$; the total amount of share in \RSM{} $\SMR{i}$ is then 
$\sum_{l=1}^{\abs{\n{i}}} \share{l}$.
A stake-based consensus algorithm is safe as  as long as replicas totaling no more than $\rf{i}$ shares behave maliciously. The system is live as long as no more than $\uf{i}$ shares fail. We further assume that the share assignment within an \RSM{} is publicly known. Traditional \CFT{} and \BFT{} algorithms simply set all shares equal to one.

{\bf Adversary Model and Reconfigurations.}
We assume the existence of a standard adversary which can corrupt arbitrary nodes, delay and reorder messages but cannot break cryptographic primitives.
We further assume the existence of periodic reconfigurations, either for membership changes or share redistribution. We assume that there exists a mechanism for an RSM to reliably learn of the new configuration and/or share assignments. This model aligns well with the model chosen in most existing consensus protocols. Proof-of-Stake blockchain protocols, for instance, assume a "slow" adversary and "slow changing stakes" such that there exists a period of time during which stake does not change and where the adversary cannot change which nodes it controls~\cite{ethereum-stake-withdrawl,algorand-stake-withdrawl}.  Similarly, all Raft implementations assume that, once crashed, a node will not recover independently~\cite{etcd-raft}. 


