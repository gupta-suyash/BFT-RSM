\section{Failures}
Our \Shadow{} protocol permits up to $\f{\Replicas{}}$ in each cluster to act maliciously.
These replicas may decide to delay or avoid sending a message. 
As our \Shadow{} protocol is {\em asynchronous} in nature and guarantees liveness only when the network is reliable, 
we cannot employ timers to resolve byzantine attacks.
However, the robust design of our \Shadow{} protocol requires minimal changes to handle these byzantine attacks, 
which we illustrate next.

\begin{itemize}[wide]
\item {\bf \em Decide.}
We know that each sending side replica removes a message $m$ with sequence number $k$ from its $\Sbuf{}$ or $\Hbuf{}$ 
after it has been majority acknowledged ($\f{\Replicas{}}+1$ $\Ack{l}$ messages from distinct replicas at receiving cluster, such that $k \le l$).
Post this, each replica updates the \highest{} variable to reflect that $m$ is the highest sequence number messages acknowledged till now.

Assume that the replica $\Replica{\Cluster{X}}{i}$ sends a message $m'$ with sequence number $l$ ($l = k+1$) to replica $\Replica{\Cluster{Y}}{j}$.
All the replicas of cluster $\Cluster{X}$ have majority acknowledged $m$ and $\highest$ is set to $m$ (sequence $k$).
If either $\Replica{\Cluster{X}}{i}$ or $\Replica{\Cluster{Y}}{j}$ are byzantine, following two cases are possible:
(i) all the honest replicas in $\Cluster{Y}$ may not receive $m'$, and 
(ii) all the honest replicas in $\Cluster{X}$ may not receive $\f{\Replicas{}}+1$ $\Ack{l}$ messages.

The latter case is of specific interest because it implies that 
each replica in $\Cluster{X}$ will receive more than $\f{\Replicas{}}+1$ $\Ack{k}$ messages corresponding to $m$.
This is possible because each replica of $\Cluster{Y}$ is required to send an acknowledgment message along with any message it wants to send. 
As this acknowledgment message represents the longest contiguous stream of messages received, and 
less than $\f{\Replicas{}}+1$ replicas of $\Cluster{Y}$ have received $m'$, so they continue sending acknowledgments for $m$.
Eventually, at least $2\f{\Replicas{}}+1$ replicas in $\Cluster{Y}$ would end up sending 
{\em two} $\Ack{k}$ messages each to all the replicas in $\Cluster{X}$.
At this point, the replicas in $\Cluster{X}$ decide that message $m'$ needs to communicated between another {\em distinct pair} of replicas.


\item {\bf \em Switch.}
We require replicas to deterministically select a new pair of replicas to communicate message $m'$. 
Our deterministic scheme is simply switching to the next pair of replicas; 
previously, if replica $\Replica{\Cluster{X}}{i}$ sent $m'$ to replica $\Replica{\Cluster{Y}}{j}$, now 
replica $\Replica{\Cluster{X}}{(i+1)}$ sent $m'$ to replica $\Replica{\Cluster{Y}}{(j+1)}$.
As every replica in cluster $\Cluster{X}$ can independently determine the next pair of replicas, 
so $\Replica{\Cluster{X}}{(i+1)}$ is expected to automatically send $m'$ when it is its turn. 
Hence, no communication among the replicas is needed for this switch.

What if even $\Replica{\Cluster{X}}{(i+1)}$ is byzantine, then like earlier case, eventually, 
each replica in $\Cluster{X}$ would receive third $\Ack{k}$ message from at least $2\f{\Replicas{}}+1$ in $\Cluster{Y}$. 
This will trigger another switch and a new pair of replicas will be expected to communicate $m'$.
Note: this pair switching can take place at most $2\f{\Replicas{}}$ times as after that there is 
a guarantee that the next pair will be honest.
Moreover, this switching does not prevent communication of other messages.



\end{itemize}


\section{Formalization}
\subsection{Thinking in terms of TCP - Michaela [Notes are very messy rn, will clean up]}
\begin{enumerate}
	\item \href{https://www.ietf.org/rfc/rfc793.txt}{RFC}
\end{enumerate}
We have been discussing how Scrooge should be providing guarantees analogous to that of TCP. Looking at the TCP specification, it seems that it has 
a couple key properties:
\begin{enumerate}
	\item Basic Data Transfer: Relatively straightforward to make analogous with. We decide when to send and how to package data.
		Key element of this is a "push" functionality to ensure \textbf{all} the data the user wishes to send is sent. I think we can
		easily provide this functionality.
	\item Reliability: We must recover data that is damaged, lost, duplicated, or delivered out of order. Via the sequential acking
		technique, it seems we should cover this point easily. Are there any other guarantees we need to provide?
	\item Flow Control: We must provide a means for regulating how many packets a sender is sending to the receiver. We could most
		likely just do what TCP does and provide a sliding window to determine what messages should be sent. This is based off the
		number of acks received.
	\item Multiplexing
	\item Connections
	\item Precedence and Security: Also seems fairly straightforward, We don't stop the participating RSMs from signing their messages
		or making them more secure.
\end{enumerate}

Beyond these properties, I think it is also important to very clearly define:
\begin{enumerate}
	\item What are the endpoints in our protocol? In the TCP RFC, it states: "The TCP is intended to be a host-to-host protocol 
		in common use in multiple networks." What are our "hosts"? I think our protocol must have \textbf{two} layers to deal with
		the two levels of communication guarantees we want to provide: \textbf{node} level and \textbf{cluster} level.
\end{enumerate}

\subsection{Thinking in terms of TCP - Reggie}

Page 9 - acks

