\section{Failures}
\Scrooge{} permits up to $\f{}$ in each cluster to act byzantine.
These replicas may decide to delay or avoid sending a message. 
Further, \Scrooge{} guarantees message delivery between two \RSM{s} in an 
{\em asynchronous} network if the messages are eventually delivered.
However, in a practical setting, we permit replicas to set timers that help them to quickly make progress.
To allow our \Scrooge{} protocol to handle byzantine attacks, 
we need to make minimal changes to the protocol stated in Section~\ref{s:algo}.

In each \RSM{}, as any of the $\f{}$ replicas out of $\n{}$ may act byzantine, 
so it is possible that a sending replica, receiving replica or both could be byzantine. 
In such a case, the honest replicas of the receiving \RSM{} may not receive one or more messages, 
which would prevent the longest contiguous acknowledgment set from increasing.
As a result, the replicas of the receiving \RSM{}  
would continue sending the same cumulative acknowledgement.
To detect this attack, \Scrooge{} require honest replicas of the sending \RSM{} to 
track cumulative acknowledgments and trigger a new pair of replicas to {\em re-send} the impacted message.
Further, to reduce communication among replicas, we require each replica to independently 
detect this attack and to proceed with its resolution.
Specifically, we expect each honest replica to run the following steps.


\begin{itemize}[wide]
\item {\bf \em Decide.}
At the $l$-th replica $\Replica{i}{l}$ of \RSM{} $\SMR{i}$, assume $\highest{}$ is the sequence number of the 
last acknowledged message by $\f{j}+1$ replicas of \RSM{} $\SMR{j}$.
This message can be acknowledged by at most $\n{j}$ replicas of \RSM{} $\SMR{j}$.
Let us represent this set of acknowledging replicas as $\RAS{}$, where $\abs{\RAS} \le \n{j}$.
% 
If the replica $\Replica{i}{l}$ receives {\em one more} acknowledgement message for the $\highest{}$ 
message from at least $\f{j}+1$ replicas in set $\RAS{}$, then $\Replica{i}{l}$ assumes that the subsequent message with the 
sequence number $\highest + 1$ did not get successfully delivered.



\item {\bf \em Switch.}
If the replica $\Replica{i}{l}$ discovers additional set of acknowledgments, it does the following tasks:
(1) It discovers the pair of replica responsible for communicating this message; this task can be deterministically determined by each replica.
Say $b$-th replica ($b \neq l$) of \RSM{} $\SMR{i}$ was supposed to send the message to $c$-th replica of \RSM{} $\SMR{j}$.
(2) If $l = (b+1) \bmod \n{i}$, then the replica $\Replica{i}{l}$ decides to send the message with sequence number $\highest+1$ 
to replica $\Replica{j}{c'}$ of \RSM{} $\SMR{j}$, where $c' = (c+1) \bmod \n{j}$.


\item {\bf Tracking.}
In the case, $l \neq (b+1) \bmod \n{i}$, replica $\Replica{i}{l}$ continues tracking if the message 
$\highest+1$ is delivered or not.
This step is necessary as the subsequent pair of communicating replicas could have a byzantine party. 
As at most $\f{i}+\f{j}$ communicating pairs could be byzantine, so $\Replica{i}{l}$ 
may have to wait for at least $\f{j}+1$ replicas each to send $\f{i}+\f{j}+1$ duplicate acknowledgments for the $\highest{}$ message 
before it is $\Replica{i}{l}$'s turn to send the ($\highest+1$)-th message.


\end{itemize}
