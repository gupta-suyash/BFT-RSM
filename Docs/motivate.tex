\section{Case for Cross-Cluster Communication}
\begin{itemize}[wide]
\item A large subset of present-day applications require communications 
between two or more clusters of nodes. 

\item For example, almost all the popular databases, such as Spanner, Cassandra, 
HBase, HDFS, and MongoDB implement some form of data-sharding. 
Spanner, for instance, splits data across multiple shards, where each shard runs an 
\RSM{} that employs a crash-fault tolerant (\CFT{}) consensus protocol like Paxos to 
manage state.
Cross-shard transactions force Spanner to access data from multiple shards.

\item In the financial world, it is common for users to move their assets from one 
organization to another. 
For instance, Robinhood Inc's incentives like free-stock trading and up to $\$75$ 
account-transfer remuneration has led to a large number of users switching their brokerage 
accounts to Robinhood.
Similarly, with a swelling number of cryptocurrencies, users are making use of either brokers 
like Coinbase and Binance, or smart-contract bridges to move their assets across cryptocurrencies.

\end{itemize}

\subsection{Limitations of Existing Solutions}
\begin{itemize}[wide]
\item Surprisingly, despite numerous applications requiring cross-cluster communication, 
there does not exist a primitive that explains this communication pattern. 

\item {\em Reliable Broadcast} (\Name{rb}) defines the broadcast operation by a correct sender; 
if a correct sender broadcasts a message, then eventually all correct receivers will deliver the message. 
Similarly, its variant, {\em Byzantine Reliable Broadcast} (\Name{brb}), defines 
broadcast operation under malicious failures.

\item However, these primitives do not sufficiently express cross-cluster communication 
as they mask the state of messages sent and delivered.
\Name{rb} and \Name{brb} allow an honest sender to send any message (faulty or correct) and 
only require all honest receivers to deliver the same message.

\item These primitives, when superimposed on cross-cluster communication, prevent \RSM{s} 
from guarding themselves against arbitrary messages.

\item We bridge this gap by defining \CCC{} primitive that takes into account the nature of 
messages communicated among \RSM{s}.
Specifically, an \RSM{} only sends a message $m$ if a quorum of its replicas {\em agree}
to send $m$.
To reach such an agreement, the replicas participate in a consensus protocol.


\item Although existing literature includes ad hoc implementations of \CCC{} primitive,
these implementations fail to meet all the three challenges we state in \S\ref{s:intro}.

\item For example, it is trivial for Spanner to process cross-shard transactions as it 
assumes the leader of each shard is honest and manage all communication. 
However, recent distributed systems that permit malicious leaders~\cite{aaa}, cannot rely on 
leaders for reliable cross-cluster communication.
These systems enable {all-to-all} protocol or its variants for such communications.
Unfortunately, these variants are unscalable as they create excessive copies of each message.

\item Similarly, a large subset of financial world transactions among multiple organizations 
is secured through a third-party broker or a programmable code. 
Unfortunately, relying on a third party makes this design centralized and prone to attacks; 
if the trusted entity is compromised, the resulting transactions are useless. 


\item In this paper, we present our novel \Scrooge{} protocol that meets all the challenges.
It does not trust any replica, broker, or programmable contract. 
It promotes a distributed design and guarantees zero-copy message delivery in the good case.


\end{itemize}