\section{Formalization}
\subsection{Micah: Current focus is redefining TCP Philosophy and 6 TCP guarantees for BFT cluster communication}
Beyond these properties, I think it is also important to very clearly define:
\begin{enumerate}
    \item What are the endpoints in our protocol? In the TCP RFC, it states: 'The TCP is intended to be a host-to-host protocol 
        in common use in multiple networks.' What are our 'hosts'? I think our protocol must have \textbf{two} layers to deal with
        the two levels of communication guarantees we want to provide: \textbf{node/host} level and \textbf{cluster} level.
\end{enumerate}

\subsubsection{Byzantine Cluster Internetwork System}
A standard notion of internetwork systems is defined in Section 2.1 of the TCP RFC 793. Here, we reframe the standard:
\begin{enumerate}
    \item All hosts in the system are a member of a larger cluster. In order to be a Byzantine Cluster Internetwork System, there must be two or more participating clusters. Other hosts who are unrelated to this network maybe be reachable via the internet, but they are not counted as participating members of the system until they become active members of at least one cluster.
    \item There is another layer of communication between clusters in our proposed model. Instead of only defining flow of packets to occur between individual hosts, we introduce another view where packets flow from one cluster to another cluster. While this different viewpoint does not tangibly change the data being transferred or how it is being transferred (it is still done at the host level), it is important abstraction to specify given it changes how we view the communication properties.
\end{enumerate}

\subsubsection{Byzantine Hosts}
Hosts can be Byzantine. This means a host can actively drop, damage, duplicate, and forge packets as well as flood nodes with packets as a denial-of-service attack. The protocol can continue functioning as expected given a limited number of Byzantine hosts per cluster. Specifically, for a cluster of size $n_c$, the protocol can handle up to $f_c$ Byzantine hosts where $n_c \geq 3f_c + 1$. Note we define hosts the same way as TCP RFC 793.

\subsubsection{Byzantine Channel}
A Byzantine Channel is defined as the communication channel between two clusters of nodes in a Byzantine Cluster Internetwork system.

\subsubsection{Byzantine Channel Protocol [Can change name later]}
BCP is intended to provide a reliable cluster-to-cluster communication service in a multinetwork environment, where each cluster is compromised of a series of individually communicating hosts. It satisfies the following cluster communication properties:
\begin{enumerate}
    \item \textbf{Basic Data Transfer:} Relatively straightforward to make analogous with. We decide when to send and how to package data. Key element of this is a "push" functionality to ensure \textbf{all} the data the user wishes to send is sent. I think we can easily provide this functionality.
    \item \textbf{Cluster Reliability:} The BCP must recover from data that is damaged, lost/dropped, duplicated or delivered out of order.  To accomplish this, we also use sequential acking techniques. There is functionally no difference is this type of reliability at the cluster level because at the cluster level, it is not majority "Byzantine". This means that the only add on is that the numberof Byzantine nodes must be limited to the value defined above.
    \item \textbf{Precedence and Security:} Also seems fairly straightforward, We don't stop the participating RSMs from signing their messages or making them more secure. (this would be the big point, since this would cover the case of message forging).
\end{enumerate}

Additionally, it adheres to the following honest host communication properties:
\begin{enumerate}
    \item \textbf{Host Reliability:} We must recover data that is damaged, lost, duplicated, or delivered out of order. Via the sequential acking technique, it seems we should cover this point easily. The difference between this and cluster reliability is that this guarantee is held even when the host itself is Byzantine or the host it is communicating with is Byzantine, as long as cluster reliability property holds. The way it deals with out of order packets is still by sending packets it has and not waiting (need to formalize this notion, it is slightly different than how we traditionally think of TCP)
	\item \textbf{Flow Control:} We must provide a means for regulating how many packets a sender is sending to the receiver (which I believe we do - similar to TCP). This is based off the number of acks received.
    \item \textbf{Multiplexing:} We will just be ripping this right from TCP and creating the standard socket connections. Not much innovation to do here.
    \item \textbf{Host Connections:} A connection is defined by data kept about the data stream, including sequence id, window size, and sockets. We do not define connections at the cluster level because a connection is defined as a uniquely specified pair of sockets identifying two sides.
\end{enumerate}
We make no guarantees about the properties of Byzantine hosts. We do not offer any way to identify such nodes, just overarching mitigations and assumptions at the cluster and to handle these cases.

\subsubsection{Definitions}
There were a couple definitions that we discussed last time that we thought are more illuminated by this new cluster-host model:
\begin{enumerate}
	\item Send (host): We can think about sending a message at the host level. This is the same concept as a host sending message over TCP. 
	\item Receive (host): We can think about receiving a message at the host level. If a host in the receiving cluster has received the message, they should acknowledge this by acking back. This should be a similar definition to receiving a packet in TCP. It's both the node receiving the packet and acking that packet
	\item Commit (cluster): We can think about committing a message at the cluster level. To send a message means to first 1) get a majority of honest nodes to approve of sending a cross-chain message $m_i$ and 2) to send a message $m_i$ to a different cluster over a network connection using a host machine in the cluster.
	\item Deliver (cluster): We can think about delivering a message at the cluster level. To receive a message means that 1) all honest nodes in the cluster have access to the message $m_i$, 2) the sending cluster has received a series of $f+1$ acks to alert them that the message was successfully received, and optionally 3) the receiving cluster can prove that the sending cluster did indeed send $m_i$ (threshold signatures, etc.)
\end{enumerate}
It seems like we are using a reliable asynchronous?? form of communication. Maybe not actually...
\begin{enumerate}
    \item Asynchronous: We use an unreliable asynchronous communication system. Unreliable due to the inherent unreliability of network connections. Asynchronous because we wait a certain number of rounds before determining if a message was not successfully sent or not.
    \item Any timing assumptions: We will use a $\delta$ exponential backoff timer to determine how long to wait until resending a message.
    \item Correctness: ?
    \item Safety: ?
    \item Liveness: ?  
	\item Proof of Stake vs. Physical nodes?
\end{enumerate}
Possible observation: We can provide no stronger guarantees than the ones currently provided by the BFT the cluster is running.

\subsubsection{Questions I have}
\begin{enumerate}
    \item Are we responsible for putting up some protections against DoS attacks? If so, we could some rate limiting scheme where if a node receives multiple packets from a node without seeing n-1 other packets first, then it drops the connection? Not sure though
    \item Mismatched number of nodes?
    \item Will a node ever be a member of multiple clusters?
    \item If we end up having a committee talking to another committee, then that will probably have to be included in the protocol specification
    \item Do all the definitions/assumptions line up with the asynchronous model we are building?
    \item How does timing come into play when we use counting acks to determine when to resend messages? Do we have a timeout?
    \item Look at HoneyBadger and assumptions made there
\end{enumerate}

\subsubsection{Sources:}
\begin{enumerate}
    \item \href{https://www.ietf.org/rfc/rfc793.txt}{RFC}
\end{enumerate}

\subsection{Thinking in terms of TCP - Reggie}
Page 9 - acks 
